#!/usr/bin/ruby

require 'optparse'
require 'io/console'

require './manageuser.rb'
ManageUser.need_root_or_exit if not $DEBUG
ManageUser.setup_connection

class DelUser
  include ManageUser

  HELP = <<EOHelp
The deluser script removes LDAP user of the system.
First, it archives the user's home directory, if possible.
Next, it removes related data as shown below:
  [membership] LDAP attribute memberUid=UID,
  [   group  ] LDAP entry cn=UID,ou=Group,dc=...,
  [   user   ] LDAP entry uid=UID,ou=People,dc=....

EOHelp

  def initialize
    @config = {
      :archive_homedir => true,
      :remove_user => true,
      :remove_group => true,
      :remove_membership => true
    }
    @opts = OptionParser.new
    @opts.on('-v', '--verbose', "increase verbosity") do
      @config[:verbose] = true
    end
    @opts.on('-n', '--noop', "do nothing") do
      @config[:noop] = true
    end
    @opts.on('-m', '--[no-]membership', TrueClass, "remove memberships (default: true)") do |membership|
      @config[:remove_membership] = membership
    end
    @opts.on('-u', '--[no-]user', TrueClass, "remove the user (default: true)") do |user|
      @config[:remove_user] = user
    end
    @opts.on('-g', '--[no-]group', TrueClass, "remove the group (default: true)") do |group|
      @config[:remove_group] = group
    end
    @opts.on('-d', '--[no-]homedir', TrueClass, "archive the home directory (default: true)") do |homedir|
      @config[:archive_homedir] = homedir
    end
    @opts.on('-h', '--help', "show help message") do
      @config[:help] = true
    end 
  end

  # Parse the UID: "./deluser UID ..."
  def parse_options!(argv)
    @opts.order!(argv)
    if (!argv.empty?) then
      # Try to treat unknown option as a UID.
      set_uid(argv.shift)
      # Continue parsing
      @opts.order!(argv)
    end
  end

  def main
    # --help
    if @config[:help] then
      show_help
      exit
    end
    archive_homedir
    remove_memberships
    remove_primary_group
    remove_user
    expire
  end

  private

  def debug
    exit
  end

  def set_uid(uid)
    @uid = uid
  end

  def archive_homedir
    return if @config[:noop]
    return unless (@config[:archive_homedir])
    return unless (Dir.exists?("/home/#{@uid}"))
    tarfile = "#{TARDIR}/#{@uid}.tar"
    begin
      command = "tar cf #{tarfile} #{@uid}"
      pid = spawn(command, :chdir => "/home")
      Process.detach(pid)
      if @config[:verbose] then
        puts "Started archiving the home directory"
        puts "(pid #{pid})# #{command}"
      end
    rescue Errno::ENOENT => tar_error
      STDERR.puts tar_error
      raise "Failed to execute tar"
    end
  end

  def remove_user
    return if @config[:noop]
    return unless (@config[:remove_user])
    return unless (User.exists?(@uid))
    User.destroy(@uid)
    puts "Removed the user #{@uid}" if @config[:verbose]
  end

  def remove_primary_group
    return if @config[:noop]
    return unless (@config[:remove_group])
    return unless (User.exists?(@uid))
    return unless (Group.exists?(@uid))
    cn = User.find(@uid).primary_group.cn
    Group.destroy(cn)
    puts "Removed the group #{cn}" if @config[:verbose]
  end

  def remove_memberships
    return if @config[:noop]
    return unless (@config[:remove_membership])
    return unless (User.exists?(@uid))
    User.find(@uid).groups.each &method(:remove_membership)
  end

  def remove_membership(group)
    memberUids = group.memberUid
    memberUids.delete(@uid)
    group.memberUid = memberUids # call setter in order to overwrite
    unless group.save
      STDERR.puts group.errors.full_message
      puts group if @config[:verbose]
      exit 1
    end
    puts "Removed #{@uid} from #{@group.cn}" if @config[:verbose]
  end

  def expire
    return if @config[:noop]
    File.open(EXPIRED_LIST, 'a') do |f|
      f.puts(@uid)
    end
  end

  def show_help
    puts HELP
    puts @opts.to_s.gsub(/deluser/, 'deluser UID')
  end
end

deluser = DelUser.new
deluser.parse_options!(ARGV)
deluser.main

