#!/usr/bin/ruby

require 'optparse'
require 'io/console'
require 'open3'
require 'active_ldap'
#require 'base64'

if not $DEBUG then
	if `id -u`.to_i != 0 then
		STDERR.puts 'need root privilege!'
		exit 1
	end
end

ActiveLdap::Base.setup_connection(
	:host => 'localhost',
	:port => 389,
	:base => 'dc=math,dc=kyoto-u,dc=ac,dc=jp',
	:bind_dn => 'cn=Manager,dc=math,dc=kyoto-u,dc=ac,dc=jp',
	:password_block => Proc.new {
		# TODO: read from "ldapmanager.secret.txt"
		password = ''
		Dir.chdir(File.expand_path('../', __FILE__)) do
			system("make secret")
			password = File.open("secret/ldap.manager.secret", 'r').read.chomp
		end
		password
	}
)

class User < ActiveLdap::Base
	# uid=$(uid),ou=People,dc=math,...
	ldap_mapping :dn_attribute => 'uid',
		:prefix => 'ou=People',
		:classes => ['inetOrgPerson', 'posixAccount'],
		:scope => :one

	# Associate with primary belonged group
	belongs_to :primary_group,
		:foreign_key => 'gidNumber',
		:class_name => 'Group',
		:primary_key => 'gidNumber'

	# Associate with all belonged groups
	belongs_to :groups,
		:primary_key => 'uid',
		:class_name => 'Group',
		:many => 'memberUid'
end

class Group < ActiveLdap::Base
	# cn=$(cn),ou=Group,dc=math,...
	ldap_mapping :dn_attribute => 'cn',
		:prefix => 'ou=Group',
		:classes => ['posixGroup'],
		:scope => :one

	# Associate with primary belonged users
	has_many :primary_members,
		:foreign_key => 'gidNumber',
		:class_name => 'User',
		:primary_key => 'gidNumber'

	# Associate with all belonged users
	has_many :members,
		:wrap => 'memberUid',
		:class_name => 'User',
		:primary_key => 'uid'
end

class Deluser
	TARDIR = '/home.backup/expired'
	HELP = <<EOHelp
The deluser script removes LDAP user of the system.
First, it archives the user's home directory, if possible.
Next, it removes related data as shown below:
  [membership] LDAP attribute memberUid=UID,
  [   group  ] LDAP entry cn=UID,ou=Group,dc=...,
  [   user   ] LDAP entry uid=UID,ou=People,dc=....

EOHelp

	def initialize
		@user = nil
		@config = {
			:archive_homedir => true,
			:remove_user => true,
			:remove_group => true,
			:remove_membership => true
		}
		@opts = OptionParser.new
		@opts.on('-v', '--verbose', "increase verbosity") do
			@config[:verbose] = true
		end
		@opts.on('-n', '--noop', "do nothing") do
			@config[:noop] = true
		end
		@opts.on('-m', '--[no-]membership', TrueClass, "remove memberships (default: true)") do |membership|
			@config[:remove_membership] = membership
		end
		@opts.on('-u', '--[no-]user', TrueClass, "remove the user (default: true)") do |user|
			@config[:remove_user] = user
		end
		@opts.on('-g', '--[no-]group', TrueClass, "remove the group (default: true)") do |group|
			@config[:remove_group] = group
		end
		@opts.on('-d', '--[no-]homedir', TrueClass, "archive the home directory (default: true)") do |homedir|
			@config[:archive_homedir] = homedir
		end
		@opts.on('-h', '--help', "show help message") do
			@config[:help] = true
		end 
	end

	# Parse the UID: "./deluser UID ..."
	def parse_options!(argv)
		@opts.order!(argv)
		if (!argv.empty?) then
			# Try to treat unknown option as a UID.
			set_uid(argv.shift)
			# Continue parsing
			@opts.order!(argv)
		end
	end

	def main
		# --help
		if (@config[:help]) then
			show_help
			exit
		end
		archive_homedir(@user.uid)
		## TODO: rm -rf /home/#{uid}
		@user.groups.each do |group|
			remove_membership(group.cn, @user.uid)
		end
		remove_group(@user.primary_group.cn)
		remove_user(@user.uid)
		debug if $DEBUG
	end

	private
	def debug
		puts @config
		#puts @user
		puts @user.primary_group.cn
		puts(@user.groups.collect do |g| g.cn end)
	end

	private
	def set_uid(uid)
		if (uid && User.exists?(uid)) then
			@user = User.find(uid)
		end
	end

	private
	def archive_homedir(uid)
		return if @config[:noop]
		return unless (@config[:archive_homedir])
		return unless (Dir.exists?("/home/#{uid}"))
		tarfile = "#{TARDIR}/#{uid}.tar"
		Open3.popen3("tar cvf #{tarfile} #{uid}", :chdir => "/home") do |i, o, err, t|
			tar_error = err.read
			unless (tar_error.empty?) then
				STDERR.puts tar_error
				raise "Failed to create #{tarfile}"
			end
		end
		puts "Archived the home directory to #{tarfile}" if @config[:verbose]
	end

	private
	def remove_user(uid)
		return if @config[:noop]
		return unless (@config[:remove_user])
		return unless (User.exists?(uid))
		User.destroy(uid)
		puts "Removed the user #{uid}" if @config[:verbose]
	end

	private
	def remove_group(cn)
		return if @config[:noop]
		return unless (@config[:remove_group])
		return unless (Group.exists?(cn))
		Group.destroy(cn)
		puts "Removed the group #{cn}" if @config[:verbose]
	end

	private
	def remove_membership(cn, uid)
		return if @config[:noop]
		return unless (@config[:remove_membership])
		return unless (Group.exists?(cn))
		group = Group.find(cn)
		memberUids = group.memberUid
		memberUids.delete(uid)
		group.memberUid = memberUids # call setter in order to overwrite
		unless group.save
			STDERR.puts group.errors.full_message
			puts group if @config[:verbose]
			exit 1
		end
		puts "Removed #{uid} from #{cn}" if @config[:verbose]
	end

	def show_help
		puts HELP
		puts @opts.to_s.gsub(/deluser/, 'deluser UID')
	end
end

deluser = Deluser.new
deluser.parse_options!(ARGV)
deluser.main

